{"version":3,"sources":["../../src/components/containers/provider/index.tsx","../../src/contexts/auth/index.tsx","../../src/contexts/data/index.tsx","../../src/hooks/data/useList.ts","../../src/definitions/helpers/queryKeys/index.tsx","../../src/hooks/data/useOne.ts","../../src/hooks/data/useMany.ts","../../src/hooks/data/useUpdate.ts","../../src/hooks/data/useCreate.ts","../../src/hooks/data/useDelete.ts","../../src/hooks/data/useCreateMany.ts","../../src/hooks/data/useUpdateMany.ts","../../src/hooks/data/useDeleteMany.ts","../../src/hooks/data/useApiUrl.ts","../../src/hooks/data/useCustom.ts","../../src/hooks/data/useDataProvider.ts","../../src/hooks/invalidate/index.ts","../../src/hooks/smelt/useMutationMode.ts","../../src/contexts/smelt/index.tsx","../../src/hooks/auth/usePermissions/index.ts","../../src/hooks/auth/useGetIdentity/index.ts","../../src/hooks/auth/useLogout/index.ts","../../src/hooks/auth/useLogin/index.ts","../../src/hooks/auth/useAuthenticated/index.ts","../../src/hooks/auth/useIsAuthenticated/index.ts","../../src/hooks/auth/useIsExistAuthentication.ts"],"sourcesContent":["import React from \"react\";\nimport {\n    QueryClientProvider,\n    QueryClient,\n    QueryCache,\n    MutationCache,\n    DefaultOptions,\n} from \"react-query\";\nimport { ReactQueryDevtools } from \"react-query/devtools\";\n\nimport { AuthContextProvider } from \"../../../contexts/auth\";\nimport { DataContextProvider } from \"../../../contexts/data\";\n\nimport {\n    IDataMultipleContextProvider,\n    IDataContextProvider,\n    IAuthContext\n} from \"../../../interfaces\";\n\ninterface QueryClientConfig {\n    queryCache?: QueryCache;\n    mutationCache?: MutationCache;\n    defaultOptions?: DefaultOptions;\n}\nexport interface ProviderProps {\n    authProvider?: IAuthContext;\n    dataProvider: IDataContextProvider | IDataMultipleContextProvider;\n\n    reactQueryClientConfig?: QueryClientConfig;\n    reactQueryDevtoolConfig?: any;\n}\n\nexport const Provider: React.FC<ProviderProps> = ({\n    authProvider,\n    children,\n    reactQueryClientConfig,\n    dataProvider,\n}) => {\n    const queryClient = new QueryClient({\n        ...reactQueryClientConfig,\n        defaultOptions: {\n            ...reactQueryClientConfig?.defaultOptions,\n            queries: {\n                refetchOnWindowFocus: false,\n                keepPreviousData: true,\n                ...reactQueryClientConfig?.defaultOptions?.queries,\n            },\n        },\n    });\n\n    return (\n        <QueryClientProvider client={queryClient}>\n            <AuthContextProvider {...authProvider} isProvided={!!authProvider}>\n            <DataContextProvider {...dataProvider}>\n                <>{children}</>\n            </DataContextProvider>\n            </AuthContextProvider>\n            <ReactQueryDevtools\n                initialIsOpen={false}\n                position=\"bottom-right\"\n                {...reactQueryClientConfig}\n            />\n        </QueryClientProvider>\n    );\n};\n","import React, { useEffect, useState } from \"react\";\nimport { useQueryClient } from \"react-query\";\n\n\nimport { IAuthContext } from \"../../interfaces\";\n\nconst defaultProvider: IAuthContext = {\n    login: () => Promise.resolve(),\n    logout: () => Promise.resolve(),\n    checkAuth: () => Promise.resolve(),\n    checkError: () => Promise.resolve(),\n    getPermissions: () => Promise.resolve(),\n    getUserIdentity: () => Promise.resolve(),\n};\nexport const AuthContext = React.createContext<IAuthContext>(defaultProvider);\n\nexport const AuthContextProvider: React.FC<Partial<IAuthContext>> = ({\n    login = defaultProvider.login,\n    logout = defaultProvider.logout,\n    checkAuth = defaultProvider.checkAuth,\n    checkError = defaultProvider.checkError,\n    getPermissions = defaultProvider.getPermissions,\n    getUserIdentity = defaultProvider.getUserIdentity,\n    isProvided,\n    children,\n}) => {\n    const [isAuthenticated, setAuthenticated] = useState(false);\n    const queryClient = useQueryClient();\n\n    useEffect(() => {\n        queryClient.invalidateQueries([\"useAuthenticated\"]);\n    }, [isAuthenticated]);\n\n    const loginFunc = async (params: any) => {\n        try {\n            const result = await login(params);\n            setAuthenticated(true);\n            return Promise.resolve(result);\n        } catch (error) {\n            setAuthenticated(false);\n            throw error;\n        }\n    };\n\n    const logoutFunc = async (params: any) => {\n        try {\n            const redirectPath = await logout(params);\n            setAuthenticated(false);\n\n            return Promise.resolve(redirectPath);\n        } catch (error) {\n            setAuthenticated(true);\n            throw error;\n        }\n    };\n\n    const checkAuthFunc = async (params: any) => {\n        try {\n            await checkAuth(params);\n            setAuthenticated(true);\n        } catch (error) {\n            if ((error as { redirectPath?: string })?.redirectPath) {\n               console.log( error.redirectPath);\n            }\n            setAuthenticated(false);\n            throw error;\n        }\n    };\n\n    return (\n        <AuthContext.Provider\n            value={{\n                login: loginFunc,\n                logout: logoutFunc,\n                checkAuth: checkAuthFunc,\n                checkError,\n                getPermissions,\n                getUserIdentity,\n                isAuthenticated,\n                isProvided,\n            }}\n        >\n            {children}\n        </AuthContext.Provider>\n    );\n};","import React from \"react\";\n\nimport {\n    IDataContextProvider,\n    IDataMultipleContextProvider,\n} from \"../../interfaces\";\n\nexport const defaultDataProvider = () => {\n    return {\n        default: {\n            create: () => Promise.resolve({ data: { id: 1 } }),\n            createMany: () => Promise.resolve({ data: [] }),\n            deleteOne: () => Promise.resolve({ data: { id: 1 } }),\n            deleteMany: () => Promise.resolve({ data: [] }),\n            getList: () => Promise.resolve({ data: [], total: 0 }),\n            getMany: () => Promise.resolve({ data: [] }),\n            getOne: () => Promise.resolve({ data: { id: 1 } }),\n            update: () => Promise.resolve({ data: { id: 1 } }),\n            updateMany: () => Promise.resolve({ data: [] }),\n            custom: () => Promise.resolve({ data: {} }),\n            getApiUrl: () => \"\",\n        },\n    };\n};\n\nexport const DataContext = React.createContext<IDataMultipleContextProvider>(\n    defaultDataProvider() as IDataMultipleContextProvider,\n);\n\nexport const DataContextProvider: React.FC<\n    IDataMultipleContextProvider | IDataContextProvider\n> = ({ children, ...rest }) => {\n    let dataProviders;\n    if (\n        !rest.hasOwnProperty(\"updateMany\") ||\n        !rest.hasOwnProperty(\"createMany\")\n    ) {\n        dataProviders = rest as IDataMultipleContextProvider;\n    } else {\n        dataProviders = {\n            default: rest,\n        } as IDataMultipleContextProvider;\n    }\n    return (\n        <DataContext.Provider value={dataProviders}>\n            {children}\n        </DataContext.Provider>\n    );\n};","import { QueryObserverResult, useQuery, UseQueryOptions } from \"react-query\";\nimport {\n    GetListResponse,\n    CrudFilters,\n    Pagination,\n    BaseRecord,\n    HttpError,\n    CrudSorting,\n    MetaDataQuery,\n} from \"../../interfaces\";\nimport { useDataProvider } from \".\";\nimport { queryKeys } from \"../../definitions/helpers/queryKeys\";\n\nexport interface UseListConfig {\n    pagination?: Pagination;\n    sort?: CrudSorting;\n    filters?: CrudFilters;\n}\n\nexport type UseListProps<TData, TError> = {\n    resource: string;\n    config?: UseListConfig;\n    queryOptions?: UseQueryOptions<GetListResponse<TData>, TError>;\n    metaData?: MetaDataQuery;\n    dataProviderName?: string;\n};\n\nexport const useList = <\n    TData extends BaseRecord,\n    TError extends HttpError = HttpError\n>({\n    resource,\n    config,\n    queryOptions,\n    metaData,\n    dataProviderName,\n}: UseListProps<TData, TError>): QueryObserverResult<\n    GetListResponse<TData>,\n    TError\n> => {\n    const dataProvider = useDataProvider();\n    const queryKey = queryKeys(resource, dataProviderName, metaData);\n    const { getList } = dataProvider(dataProviderName);\n\n    const queryResponse = useQuery<GetListResponse<TData>, TError>(\n        queryKey.list(config),\n        () => getList<TData>({ resource, ...config, metaData }),\n        {\n            ...queryOptions,\n            onSuccess: (data) => {\n                queryOptions?.onSuccess?.(data);\n            },\n            onError: (err: TError) => {\n                queryOptions?.onError?.(err);\n            },\n        }\n    );\n\n    return queryResponse;\n};\n","import { IQueryKeys } from \"../../../interfaces\";\nimport { QueryKey } from \"react-query\";\n\nimport { MetaDataQuery } from \"../../../interfaces\";\n\nexport const queryKeys = (\n    resource: string,\n    dataProviderName?: string,\n    metaData?: MetaDataQuery | undefined,\n): IQueryKeys => {\n    const providerName = dataProviderName || \"default\";\n    const keys: IQueryKeys = {\n        all: [providerName],\n        resourceAll: [providerName, resource],\n        list: (config) => [\n            ...keys.resourceAll,\n            \"list\",\n            { ...config, ...metaData } as QueryKey,\n        ],\n        many: (ids) =>\n            [\n                ...keys.resourceAll,\n                \"getMany\",\n                (ids && ids.map(String)) as QueryKey,\n                { ...metaData } as QueryKey,\n            ].filter((item) => item !== undefined),\n        detail: (id) => [\n            ...keys.resourceAll,\n            \"detail\",\n            id?.toString(),\n            { ...metaData } as QueryKey,\n        ],\n    };\n    return keys;\n};","import { QueryObserverResult, useQuery, UseQueryOptions } from \"react-query\";\n\nimport {\n  GetOneResponse,\n  HttpError,\n  BaseRecord,\n  BaseKey,\n  MetaDataQuery,\n} from \"../../interfaces\";\nimport { useDataProvider } from \"../data\";\nimport { queryKeys } from \"../../definitions/helpers/queryKeys\";\n\nexport type UseOneProps<TData, TError> = {\n  resource: string;\n  id: BaseKey;\n  queryOptions?: UseQueryOptions<GetOneResponse<TData>, TError>;\n\n  metaData?: MetaDataQuery;\n  dataProviderName?: string;\n};\n\nexport const useOne = <\n  TData extends BaseRecord = BaseRecord,\n  TError extends HttpError = HttpError\n>({\n  resource,\n  id,\n  queryOptions,\n  metaData,\n  dataProviderName,\n}: UseOneProps<TData, TError>): QueryObserverResult<GetOneResponse<TData>> => {\n  const dataProvider = useDataProvider();\n  const queryKey = queryKeys(resource, dataProviderName, metaData);\n\n  const { getOne } = dataProvider(dataProviderName);\n\n  const queryResponse = useQuery<GetOneResponse<TData>, TError>(\n    queryKey.detail(id),\n    () => getOne<TData>({ resource, id, metaData }),\n    {\n      ...queryOptions,\n      onSuccess: (data) => {\n        queryOptions?.onSuccess?.(data);\n      },\n      onError: (err: TError) => {\n        queryOptions?.onError?.(err);\n      },\n    }\n  );\n\n  return queryResponse;\n};\n","import { QueryObserverResult, useQuery, UseQueryOptions } from \"react-query\";\n\nimport {\n  BaseRecord,\n  BaseKey,\n  GetManyResponse,\n  HttpError,\n  MetaDataQuery,\n} from \"../../interfaces\";\nimport { useDataProvider } from \"../data\";\nimport { queryKeys } from \"../../definitions/helpers/queryKeys\";\n\nexport type UseManyProps<TData, TError> = {\n  resource: string;\n  ids: BaseKey[];\n  queryOptions?: UseQueryOptions<GetManyResponse<TData>, TError>;\n\n  metaData?: MetaDataQuery;\n  dataProviderName?: string;\n};\n\nexport const useMany = <\n  TData extends BaseRecord = BaseRecord,\n  TError extends HttpError = HttpError\n>({\n  resource,\n  ids,\n  queryOptions,\n  metaData,\n  dataProviderName,\n}: UseManyProps<TData, TError>): QueryObserverResult<\n  GetManyResponse<TData>\n> => {\n  const dataProvider = useDataProvider();\n  const queryKey = queryKeys(resource, dataProviderName, metaData);\n\n  const { getMany } = dataProvider(dataProviderName);\n\n  const isEnabled =\n    queryOptions?.enabled === undefined || queryOptions?.enabled === true;\n\n  const queryResponse = useQuery<GetManyResponse<TData>, TError>(\n    queryKey.many(ids),\n    () => getMany<TData>({ resource, ids, metaData }),\n    {\n      ...queryOptions,\n      onSuccess: (data) => {\n        queryOptions?.onSuccess?.(data);\n      },\n      onError: (err: TError) => {\n        queryOptions?.onError?.(err);\n      },\n    }\n  );\n\n  return queryResponse;\n};\n","import { useMutation, UseMutationResult, useQueryClient } from 'react-query'\n\nimport {\n  BaseRecord,\n  BaseKey,\n  UpdateResponse,\n  MutationMode,\n  PrevContext as UpdateContext,\n  HttpError,\n  MetaDataQuery,\n  PreviousQuery,\n  GetListResponse,\n  IQueryKeys\n} from '../../interfaces'\nimport { useMutationMode, useDataProvider, useInvalidate } from '../../hooks'\nimport { queryKeys } from '../../definitions/helpers/queryKeys'\n\nexport type UpdateParams<TVariables> = {\n  id: BaseKey\n  resource: string\n  mutationMode?: MutationMode\n  undoableTimeout?: number\n  onCancel?: (cancelMutation: () => void) => void\n  values: TVariables\n  metaData?: MetaDataQuery\n  dataProviderName?: string\n  invalidates?: Array<keyof IQueryKeys>\n}\n\nexport type UseUpdateReturnType<\n  TData extends BaseRecord = BaseRecord,\n  TError extends HttpError = HttpError,\n  TVariables = {}\n> = UseMutationResult<\n  UpdateResponse<TData>,\n  TError,\n  UpdateParams<TVariables>,\n  UpdateContext<TData>\n>\n\n\nexport const useUpdate = <\n  TData extends BaseRecord = BaseRecord,\n  TError extends HttpError = HttpError,\n  TVariables = {}\n>(): UseUpdateReturnType<TData, TError, TVariables> => {\n  const queryClient = useQueryClient()\n  const dataProvider = useDataProvider()\n\n  const {\n    mutationMode: mutationModeContext,\n    undoableTimeout: undoableTimeoutContext\n  } = useMutationMode()\n  const invalidateStore = useInvalidate()\n\n  const mutation = useMutation<\n    UpdateResponse<TData>,\n    TError,\n    UpdateParams<TVariables>,\n    UpdateContext<TData>\n  >(\n    ({\n      id,\n      values,\n      resource,\n      mutationMode,\n      undoableTimeout,\n      onCancel,\n      metaData,\n      dataProviderName\n    }) => {\n      const mutationModePropOrContext = mutationMode ?? mutationModeContext\n\n      const undoableTimeoutPropOrContext =\n        undoableTimeout ?? undoableTimeoutContext\n\n      if (!(mutationModePropOrContext === 'undoable')) {\n        return dataProvider(dataProviderName).update<TData, TVariables>({\n          resource,\n          id,\n          variables: values,\n          metaData\n        })\n      }\n      const updatePromise = new Promise<UpdateResponse<TData>>(\n        (resolve, reject) => {\n          const doMutation = () => {\n            dataProvider(dataProviderName)\n              .update<TData, TVariables>({\n                resource,\n                id,\n                variables: values,\n                metaData\n              })\n              .then(result => resolve(result))\n              .catch(err => reject(err))\n          }\n\n          const cancelMutation = () => {\n            reject({ message: 'mutationCancelled' })\n          }\n\n          if (onCancel) {\n            onCancel(cancelMutation)\n          }\n        }\n      )\n      return updatePromise\n    },\n    {\n      onMutate: async ({\n        resource,\n        id,\n        mutationMode,\n        values,\n        dataProviderName\n      }) => {\n        const queryKey = queryKeys(resource, dataProviderName)\n\n        const previousQueries: PreviousQuery<\n          TData\n        >[] = queryClient.getQueriesData(queryKey.resourceAll)\n\n        const mutationModePropOrContext = mutationMode ?? mutationModeContext\n\n        await queryClient.cancelQueries(queryKey.resourceAll, undefined, {\n          silent: true\n        })\n\n        if (!(mutationModePropOrContext === 'pessimistic')) {\n          // Set the previous queries to the new ones:\n          queryClient.setQueriesData(\n            queryKey.list(),\n            (previous?: GetListResponse<TData> | null) => {\n              if (!previous) {\n                return null\n              }\n              const data = previous.data.map((record: TData) => {\n                if (record.id?.toString() === id?.toString()) {\n                  return ({\n                    id,\n                    ...values\n                  } as unknown) as TData\n                }\n                return record\n              })\n\n              return {\n                ...previous,\n                data\n              }\n            }\n          )\n\n          queryClient.setQueriesData(\n            queryKey.many(),\n            (previous?: GetListResponse<TData> | null) => {\n              if (!previous) {\n                return null\n              }\n\n              const data = previous.data.map((record: TData) => {\n                if (record.id?.toString() === id?.toString()) {\n                  record = ({\n                    id,\n                    ...values\n                  } as unknown) as TData\n                }\n                return record\n              })\n              return {\n                ...previous,\n                data\n              }\n            }\n          )\n\n          queryClient.setQueriesData(\n            queryKey.detail(id),\n            (previous?: GetListResponse<TData> | null) => {\n              if (!previous) {\n                return null\n              }\n\n              return {\n                ...previous,\n                data: {\n                  ...previous.data,\n                  ...values\n                }\n              }\n            }\n          )\n        }\n\n        return {\n          previousQueries,\n          queryKey\n        }\n      },\n      onSettled: (\n        _data,\n        _error,\n        {\n          id,\n          resource,\n          dataProviderName,\n          invalidates = ['list', 'many', 'detail']\n        }\n      ) => {\n        invalidateStore({\n          resource,\n          dataProviderName,\n          invalidates,\n          id\n        })\n      },\n      onSuccess: (data, { id, resource }) => {},\n      onError: (err: TError, { id, resource }, context) => {\n        // set back the queries to the context:\n\n        if (context) {\n          for (const query of context.previousQueries) {\n            queryClient.setQueryData(query[0], query[1])\n          }\n        }\n\n        if (err.message !== 'mutationCancelled') {\n        }\n      }\n    }\n  )\n\n  return mutation\n}\n","import { useMutation, UseMutationResult, useQueryClient } from \"react-query\";\nimport {\n  CreateResponse,\n  BaseRecord,\n  HttpError,\n  MetaDataQuery,\n  IQueryKeys,\n} from \"../../interfaces\";\nimport { useDataProvider, useInvalidate } from \"../../hooks\";\n\ntype useCreateParams<TVariables> = {\n  resource: string;\n  values: TVariables;\n  metaData?: MetaDataQuery;\n  dataProviderName?: string;\n  invalidates?: Array<keyof IQueryKeys>;\n};\n\nexport type UseCreateReturnType<\n  TData extends BaseRecord = BaseRecord,\n  TError extends HttpError = HttpError,\n  TVariables = {}\n> = UseMutationResult<\n  CreateResponse<TData>,\n  TError,\n  useCreateParams<TVariables>,\n  unknown\n>;\n\nexport const useCreate = <\n  TData extends BaseRecord = BaseRecord,\n  TError extends HttpError = HttpError,\n  TVariables = {}\n>(): UseCreateReturnType<TData, TError, TVariables> => {\n  const dataProvider = useDataProvider();\n  const invalidateStore = useInvalidate();\n\n  const mutation = useMutation<\n    CreateResponse<TData>,\n    TError,\n    useCreateParams<TVariables>,\n    unknown\n  >(\n    ({\n      resource,\n      values,\n      metaData,\n      dataProviderName,\n    }: useCreateParams<TVariables>) => {\n      return dataProvider(dataProviderName).create<TData, TVariables>({\n        resource,\n        variables: values,\n        metaData,\n      });\n    },\n    {\n      onSuccess: (\n        data,\n        { resource, dataProviderName, invalidates = [\"list\", \"many\"] }\n      ) => {\n\n        invalidateStore({\n          resource,\n          dataProviderName,\n          invalidates,\n        });\n      },\n      onError: (err: TError, { resource }) => {},\n    }\n  );\n\n  return mutation;\n};\n","import { useQueryClient, useMutation, UseMutationResult } from \"react-query\";\nimport pluralize from \"pluralize\";\n\nimport {\n    useMutationMode,\n    useDataProvider,\n    useInvalidate,\n} from \"../../hooks\";\nimport {\n    DeleteOneResponse,\n    MutationMode,\n    PrevContext as DeleteContext,\n    BaseRecord,\n    BaseKey,\n    HttpError,\n    GetListResponse,\n    MetaDataQuery,\n    PreviousQuery,\n    IQueryKeys,\n} from \"../../interfaces\";\nimport { queryKeys } from \"../../definitions/helpers/queryKeys\";\nexport type DeleteParams<TVariables> = {\n    id: BaseKey;\n    resource: string;\n    mutationMode?: MutationMode;\n    undoableTimeout?: number;\n    onCancel?: (cancelMutation: () => void) => void;\n    metaData?: MetaDataQuery;\n    dataProviderName?: string;\n    invalidates?: Array<keyof IQueryKeys>;\n    values?: TVariables;\n} ;\n\nexport type UseDeleteReturnType<\n    TData extends BaseRecord = BaseRecord,\n    TError = HttpError,\n    TVariables = {},\n> = UseMutationResult<\n    DeleteOneResponse<TData>,\n    TError,\n    DeleteParams<TVariables>,\n    DeleteContext<TData>\n>;\n\n\nexport const useDelete = <\n    TData extends BaseRecord = BaseRecord,\n    TError extends HttpError = HttpError,\n    TVariables = {},\n>(): UseDeleteReturnType<TData, TError, TVariables> => {\n    const dataProvider = useDataProvider();\n\n    const queryClient = useQueryClient();\n\n    const {\n        mutationMode: mutationModeContext,\n        undoableTimeout: undoableTimeoutContext,\n    } = useMutationMode();\n\n    const invalidateStore = useInvalidate();\n\n    const mutation = useMutation<\n        DeleteOneResponse<TData>,\n        TError,\n        DeleteParams<TVariables>,\n        DeleteContext<TData>\n    >(\n        ({\n            id,\n            mutationMode,\n            undoableTimeout,\n            resource,\n            onCancel,\n            metaData,\n            dataProviderName,\n            values,\n        }) => {\n            const mutationModePropOrContext =\n                mutationMode ?? mutationModeContext;\n\n            const undoableTimeoutPropOrContext =\n                undoableTimeout ?? undoableTimeoutContext;\n\n            if (!(mutationModePropOrContext === \"undoable\")) {\n                return dataProvider(dataProviderName).deleteOne<TData>({\n                    resource,\n                    id,\n                    metaData,\n                    //variables: values,\n                });\n            }\n\n            const deletePromise = new Promise<DeleteOneResponse<TData>>(\n                (resolve, reject) => {\n                    const doMutation = () => {\n                        dataProvider(dataProviderName)\n                            .deleteOne<TData>({\n                                resource,\n                                id,\n                                metaData,\n                               // variables: values,\n                            })\n                            .then((result) => resolve(result))\n                            .catch((err) => reject(err));\n                    };\n\n                    const cancelMutation = () => {\n                        reject({ message: \"mutationCancelled\" });\n                    };\n\n                    if (onCancel) {\n                        onCancel(cancelMutation);\n                    }\n\n                   \n                },\n            );\n            return deletePromise;\n        },\n        {\n            onMutate: async ({\n                id,\n                resource,\n                mutationMode,\n                dataProviderName,\n            }) => {\n                const queryKey = queryKeys(resource, dataProviderName);\n\n                const mutationModePropOrContext =\n                    mutationMode ?? mutationModeContext;\n\n                await queryClient.cancelQueries(\n                    queryKey.resourceAll,\n                    undefined,\n                    {\n                        silent: true,\n                    },\n                );\n\n                const previousQueries: PreviousQuery<TData>[] =\n                    queryClient.getQueriesData(queryKey.resourceAll);\n\n                if (!(mutationModePropOrContext === \"pessimistic\")) {\n                    // Set the previous queries to the new ones:\n                    queryClient.setQueriesData(\n                        queryKey.list(),\n                        (previous?: GetListResponse<TData> | null) => {\n                            if (!previous) {\n                                return null;\n                            }\n                            const data = previous.data.filter(\n                                (record: TData) =>\n                                    record.id?.toString() !== id.toString(),\n                            );\n\n                            return {\n                                data,\n                                total: previous.total - 1,\n                            };\n                        },\n                    );\n\n                    queryClient.setQueriesData(\n                        queryKey.many(),\n                        (previous?: GetListResponse<TData> | null) => {\n                            if (!previous) {\n                                return null;\n                            }\n                            const data = previous.data.filter(\n                                (record: TData) => {\n                                    return (\n                                        record.id?.toString() !== id?.toString()\n                                    );\n                                },\n                            );\n\n                            return {\n                                ...previous,\n                                data,\n                            };\n                        },\n                    );\n                }\n\n                return {\n                    previousQueries,\n                    queryKey,\n                };\n            },\n            onSettled: (\n                _data,\n                _error,\n                {\n                    id,\n                    resource,\n                    dataProviderName,\n                    invalidates = [\"list\", \"many\"],\n                },\n            ) => {\n                // invalidate the cache for the list and many queries:\n\n                invalidateStore({\n                    resource,\n                    dataProviderName,\n                    invalidates,\n                });\n\n              \n            },\n            onSuccess: (\n                _data,\n                { id, resource },\n                context,\n            ) => {\n\n                // Remove the queries from the cache:\n                queryClient.removeQueries(context.queryKey.detail(id));\n\n               \n            },\n            onError: (\n                err: TError,\n                { id, resource },\n                context,\n            ) => {\n                // set back the queries to the context:\n                if (context) {\n                    for (const query of context.previousQueries) {\n                        queryClient.setQueryData(query[0], query[1]);\n                    }\n                }\n\n                if (err.message !== \"mutationCancelled\") {\n                   \n\n                   \n                }\n            },\n        },\n    );\n\n    return mutation;\n};","import { useQueryClient, useMutation, UseMutationResult } from \"react-query\";\n\nimport {\n    BaseRecord,\n    CreateManyResponse,\n    HttpError,\n    MetaDataQuery,\n    IQueryKeys,\n} from \"../../interfaces\";\nimport {\n    useDataProvider,\n    useInvalidate,\n} from \"../../hooks\";\nimport pluralize from \"pluralize\";\n\ntype useCreateManyParams<TVariables> = {\n    resource: string;\n    values: TVariables[];\n    metaData?: MetaDataQuery;\n    dataProviderName?: string;\n    invalidates?: Array<keyof IQueryKeys>;\n} ;\n\nexport type UseCreateManyReturnType<\n    TData extends BaseRecord = BaseRecord,\n    TError = HttpError,\n    TVariables = {},\n> = UseMutationResult<\n    CreateManyResponse<TData>,\n    TError,\n    useCreateManyParams<TVariables>,\n    unknown\n>;\n\n\nexport const useCreateMany = <\n    TData extends BaseRecord = BaseRecord,\n    TError extends HttpError = HttpError,\n    TVariables = {},\n>(): UseCreateManyReturnType<TData, TError, TVariables> => {\n    const dataProvider = useDataProvider();\n\n    \n    const invalidateStore = useInvalidate();\n\n    const mutation = useMutation<\n        CreateManyResponse<TData>,\n        TError,\n        useCreateManyParams<TVariables>\n    >(\n        ({\n            resource,\n            values,\n            metaData,\n            dataProviderName,\n        }: useCreateManyParams<TVariables>) =>\n            dataProvider(dataProviderName).createMany<TData, TVariables>({\n                resource,\n                variables: values,\n                metaData,\n            }),\n        {\n            onSuccess: (\n                response,\n                {\n                    resource,\n                    dataProviderName,\n                    invalidates = [\"list\", \"many\"],\n                },\n            ) => {\n                const resourcePlural = pluralize.plural(resource);\n\n               \n\n                invalidateStore({\n                    resource,\n                    dataProviderName,\n                    invalidates,\n                });\n\n               \n            },\n            onError: (err: TError, { resource }) => {\n               \n            },\n        },\n    );\n\n    return mutation;\n};","import { useMutation, UseMutationResult, useQueryClient } from \"react-query\";\n\nimport { useMutationMode, useDataProvider, useInvalidate } from \"../../hooks\";\nimport {\n  BaseRecord,\n  BaseKey,\n  UpdateManyResponse,\n  HttpError,\n  MutationMode,\n  QueryResponse,\n  PrevContext as UpdateContext,\n  MetaDataQuery,\n  GetListResponse,\n  IQueryKeys,\n} from \"../../interfaces\";\nimport { queryKeys } from \"../../definitions/helpers/queryKeys\";\n\ntype UpdateManyParams<TVariables> = {\n  ids: BaseKey[];\n  resource: string;\n  mutationMode?: MutationMode;\n  undoableTimeout?: number;\n  onCancel?: (cancelMutation: () => void) => void;\n  values: TVariables;\n  metaData?: MetaDataQuery;\n  dataProviderName?: string;\n  invalidates?: Array<keyof IQueryKeys>;\n};\n\ntype UseUpdateManyReturnType<\n  TData extends BaseRecord = BaseRecord,\n  TError extends HttpError = HttpError,\n  TVariables = {}\n> = UseMutationResult<\n  UpdateManyResponse<TData>,\n  TError,\n  UpdateManyParams<TVariables>,\n  UpdateContext<TData>\n>;\n\nexport const useUpdateMany = <\n  TData extends BaseRecord = BaseRecord,\n  TError extends HttpError = HttpError,\n  TVariables = {}\n>(): UseUpdateManyReturnType<TData, TError, TVariables> => {\n  const queryClient = useQueryClient();\n  const dataProvider = useDataProvider();\n\n  const {\n    mutationMode: mutationModeContext,\n    undoableTimeout: undoableTimeoutContext,\n  } = useMutationMode();\n\n  const invalidateStore = useInvalidate();\n\n  const mutation = useMutation<\n    UpdateManyResponse<TData>,\n    TError,\n    UpdateManyParams<TVariables>,\n    UpdateContext<TData>\n  >(\n    ({\n      ids,\n      values,\n      resource,\n      onCancel,\n      mutationMode,\n      undoableTimeout,\n      metaData,\n      dataProviderName,\n    }: UpdateManyParams<TVariables>) => {\n      const mutationModePropOrContext = mutationMode ?? mutationModeContext;\n\n      const undoableTimeoutPropOrContext =\n        undoableTimeout ?? undoableTimeoutContext;\n\n      if (!(mutationModePropOrContext === \"undoable\")) {\n        return dataProvider(dataProviderName).updateMany<TData, TVariables>({\n          resource,\n          ids,\n          variables: values,\n          metaData,\n        });\n      }\n\n      const updatePromise = new Promise<UpdateManyResponse<TData>>(\n        (resolve, reject) => {\n          const doMutation = () => {\n            dataProvider(dataProviderName)\n              .updateMany<TData, TVariables>({\n                resource,\n                ids,\n                variables: values,\n                metaData,\n              })\n              .then((result) => resolve(result))\n              .catch((err) => reject(err));\n          };\n\n          const cancelMutation = () => {\n            reject({ message: \"mutationCancelled\" });\n          };\n\n          if (onCancel) {\n            onCancel(cancelMutation);\n          }\n        }\n      );\n      return updatePromise;\n    },\n\n    {\n      onMutate: async ({\n        resource,\n        ids,\n        values,\n        mutationMode,\n        dataProviderName,\n        metaData,\n      }) => {\n        const queryKey = queryKeys(resource, dataProviderName, metaData);\n\n        const mutationModePropOrContext = mutationMode ?? mutationModeContext;\n\n        await queryClient.cancelQueries(queryKey.resourceAll, undefined, {\n          silent: true,\n        });\n\n        const previousQueries = queryClient.getQueriesData<\n          QueryResponse<TData>\n        >(queryKey.resourceAll);\n\n        if (!(mutationModePropOrContext === \"pessimistic\")) {\n          // Set the previous queries to the new ones:\n          queryClient.setQueriesData(\n            queryKey.list(),\n            (previous?: GetListResponse<TData> | null) => {\n              if (!previous) {\n                return null;\n              }\n\n              const data = previous.data.map((record: TData) => {\n                if (\n                  record.id !== undefined &&\n                  ids\n                    .filter((id) => id !== undefined)\n                    .map(String)\n                    .includes(record.id.toString())\n                ) {\n                  return {\n                    ...record,\n                    ...values,\n                  };\n                }\n\n                return record;\n              });\n\n              return {\n                ...previous,\n                data,\n              };\n            }\n          );\n\n          queryClient.setQueriesData(\n            queryKey.many(),\n            (previous?: GetListResponse<TData> | null) => {\n              if (!previous) {\n                return null;\n              }\n\n              const data = previous.data.map((record: TData) => {\n                if (\n                  record.id !== undefined &&\n                  ids\n                    .filter((id) => id !== undefined)\n                    .map(String)\n                    .includes(record.id.toString())\n                ) {\n                  return {\n                    ...record,\n                    ...values,\n                  };\n                }\n                return record;\n              });\n              return {\n                ...previous,\n                data,\n              };\n            }\n          );\n          for (const id of ids) {\n            queryClient.setQueriesData(\n              queryKey.detail(id),\n              (previous?: GetListResponse<TData> | null) => {\n                if (!previous) {\n                  return null;\n                }\n\n                const data = {\n                  ...previous.data,\n                  ...values,\n                };\n                return {\n                  ...previous,\n                  data,\n                };\n              }\n            );\n          }\n        }\n\n        return {\n          previousQueries,\n          queryKey,\n        };\n      },\n      onSettled: (_data, _error, { ids, resource, dataProviderName }) => {\n        // invalidate the cache for the list and many queries:\n\n        invalidateStore({\n          resource,\n          invalidates: [\"list\", \"many\"],\n          dataProviderName,\n        });\n\n        ids.forEach((id) =>\n          invalidateStore({\n            resource,\n            invalidates: [\"detail\"],\n            dataProviderName,\n            id,\n          })\n        );\n      },\n      onSuccess: (_data, { ids, resource }) => {},\n      onError: (err: TError, { ids, resource }, context) => {\n        // set back the queries to the context:\n\n        if (context) {\n          for (const query of context.previousQueries) {\n            queryClient.setQueryData(query[0], query[1]);\n          }\n        }\n\n        if (err.message !== \"mutationCancelled\") {\n        }\n      },\n    }\n  );\n\n  return mutation;\n};\n","import { useQueryClient, useMutation, UseMutationResult } from \"react-query\";\nimport pluralize from \"pluralize\";\n\nimport {\n    DeleteManyResponse,\n    HttpError,\n    BaseRecord,\n    BaseKey,\n    MutationMode,\n    PreviousQuery,\n    GetListResponse,\n    PrevContext as DeleteContext,\n    MetaDataQuery,\n    IQueryKeys,\n} from \"../../interfaces\";\nimport {\n    useMutationMode,\n    useDataProvider,\n    useInvalidate,\n} from \"../../hooks\";\nimport { queryKeys } from \"../../definitions/helpers/queryKeys\";\n\nexport type DeleteManyParams<TVariables> = {\n    ids: BaseKey[];\n    resource: string;\n    mutationMode?: MutationMode;\n    undoableTimeout?: number;\n    onCancel?: (cancelMutation: () => void) => void;\n    metaData?: MetaDataQuery;\n    dataProviderName?: string;\n    invalidates?: Array<keyof IQueryKeys>;\n    values?: TVariables;\n} ;\n\nexport type UseDeleteManyReturnType<\n    TData extends BaseRecord = BaseRecord,\n    TError = HttpError,\n    TVariables = {},\n> = UseMutationResult<\n    DeleteManyResponse<TData>,\n    TError,\n    DeleteManyParams<TVariables>,\n    unknown\n>;\n\n\nexport const useDeleteMany = <\n    TData extends BaseRecord = BaseRecord,\n    TError extends HttpError = HttpError,\n    TVariables = {},\n>(): UseDeleteManyReturnType<TData, TError, TVariables> => {\n\n    const {\n        mutationMode: mutationModeContext,\n        undoableTimeout: undoableTimeoutContext,\n    } = useMutationMode();\n    const dataProvider = useDataProvider();\n    const invalidateStore = useInvalidate();\n\n    const queryClient = useQueryClient();\n\n    const mutation = useMutation<\n        DeleteManyResponse<TData>,\n        TError,\n        DeleteManyParams<TVariables>,\n        DeleteContext<TData>\n    >(\n        ({\n            resource,\n            ids,\n            mutationMode,\n            undoableTimeout,\n            onCancel,\n            metaData,\n            dataProviderName,\n            values,\n        }: DeleteManyParams<TVariables>) => {\n            const mutationModePropOrContext =\n                mutationMode ?? mutationModeContext;\n\n            const undoableTimeoutPropOrContext =\n                undoableTimeout ?? undoableTimeoutContext;\n            if (!(mutationModePropOrContext === \"undoable\")) {\n                return dataProvider(dataProviderName).deleteMany<TData>({\n                    resource,\n                    ids,\n                    metaData,\n                   // variables: values,\n                });\n            }\n\n            const updatePromise = new Promise<DeleteManyResponse<TData>>(\n                (resolve, reject) => {\n                    const doMutation = () => {\n                        dataProvider(dataProviderName)\n                            .deleteMany<TData>({\n                                resource,\n                                ids,\n                                metaData,\n                               // variables: values,\n                            })\n                            .then((result) => resolve(result))\n                            .catch((err) => reject(err));\n                    };\n\n                    const cancelMutation = () => {\n                        reject({ message: \"mutationCancelled\" });\n                    };\n\n                    if (onCancel) {\n                        onCancel(cancelMutation);\n                    }\n\n                 \n                },\n            );\n            return updatePromise;\n        },\n        {\n            onMutate: async ({\n                ids,\n                resource,\n                mutationMode,\n                dataProviderName,\n            }) => {\n                const queryKey = queryKeys(resource, dataProviderName);\n\n                const mutationModePropOrContext =\n                    mutationMode ?? mutationModeContext;\n\n                await queryClient.cancelQueries(\n                    queryKey.resourceAll,\n                    undefined,\n                    {\n                        silent: true,\n                    },\n                );\n\n                const previousQueries: PreviousQuery<TData>[] =\n                    queryClient.getQueriesData(queryKey.resourceAll);\n\n                if (!(mutationModePropOrContext === \"pessimistic\")) {\n                    // Set the previous queries to the new ones:\n                    queryClient.setQueriesData(\n                        queryKey.list(),\n                        (previous?: GetListResponse<TData> | null) => {\n                            if (!previous) {\n                                return null;\n                            }\n\n                            const data = previous.data.filter(\n                                (item) =>\n                                    item.id &&\n                                    !ids\n                                        .map(String)\n                                        .includes(item.id.toString()),\n                            );\n\n                            return {\n                                data,\n                                total: previous.total - 1,\n                            };\n                        },\n                    );\n\n                    queryClient.setQueriesData(\n                        queryKey.many(),\n                        (previous?: GetListResponse<TData> | null) => {\n                            if (!previous) {\n                                return null;\n                            }\n\n                            const data = previous.data.filter(\n                                (record: TData) => {\n                                    if (record.id) {\n                                        return !ids\n                                            .map(String)\n                                            .includes(record.id.toString());\n                                    }\n                                    return false;\n                                },\n                            );\n\n                            return {\n                                ...previous,\n                                data,\n                            };\n                        },\n                    );\n\n                    for (const id of ids) {\n                        queryClient.setQueriesData(\n                            queryKey.detail(id),\n                            (previous?: any | null) => {\n                                if (!previous || previous.data.id == id) {\n                                    return null;\n                                }\n                                return {\n                                    ...previous,\n                                };\n                            },\n                        );\n                    }\n                }\n\n                return {\n                    previousQueries,\n                    queryKey,\n                };\n            },\n            // Always refetch after error or success:\n            onSettled: (\n                _data,\n                _error,\n                {\n                    resource,\n                    ids,\n                    dataProviderName,\n                    invalidates = [\"list\", \"many\"],\n                },\n            ) => {\n                // invalidate the cache for the list and many queries:\n                invalidateStore({\n                    resource,\n                    dataProviderName,\n                    invalidates,\n                });\n\n                \n            },\n            onSuccess: (\n                _data,\n                { ids, resource },\n                context,\n            ) => {\n                // Remove the queries from the cache:\n                ids.forEach((id) =>\n                    queryClient.removeQueries(context.queryKey.detail(id)),\n                );\n\n            },\n            onError: (err, { ids, resource }, context) => {\n                // set back the queries to the context:\n                if (context) {\n                    for (const query of context.previousQueries) {\n                        queryClient.setQueryData(query[0], query[1]);\n                    }\n                }\n\n                if (err.message !== \"mutationCancelled\") {\n\n\n                    \n                }\n            },\n        },\n    );\n\n    return mutation;\n};","import { useDataProvider } from \"../data\";\n\nexport const useApiUrl = (dataProviderName?: string): string => {\n    const dataProvider = useDataProvider();\n\n    const { getApiUrl } = dataProvider(dataProviderName);\n\n    return getApiUrl();\n};","import { QueryObserverResult, useQuery, UseQueryOptions } from \"react-query\";\n\nimport {\n    CustomResponse,\n    CrudSorting,\n    CrudFilters,\n    BaseRecord,\n    HttpError,\n    MetaDataQuery,\n} from \"../../interfaces\";\nimport {\n    useDataProvider,\n} from \"@hooks\";\n\ninterface UseCustomConfig<TQuery, TPayload> {\n    sort?: CrudSorting;\n    filters?: CrudFilters;\n    query?: TQuery;\n    payload?: TPayload;\n    headers?: {};\n}\n\nexport type UseCustomProps<TData, TError, TQuery, TPayload> = {\n    url: string;\n    method: \"get\" | \"delete\" | \"head\" | \"options\" | \"post\" | \"put\" | \"patch\";\n    config?: UseCustomConfig<TQuery, TPayload>;\n    queryOptions?: UseQueryOptions<CustomResponse<TData>, TError>;\n    metaData?: MetaDataQuery;\n    dataProviderName?: string;\n};\n\n/**\n * `useCustom` is a modified version of `react-query`'s {@link https://react-query.tanstack.com/guides/queries `useQuery`} used for custom requests.\n *\n * It uses the `custom` method from the `dataProvider` which is passed to `<Refine>`.\n *\n * @see {@link https://refine.dev/docs/core/hooks/data/useCustom} for more details.\n *\n * @typeParam TData - Result data of the query extends {@link https://refine.dev/docs/core/interfaceReferences#baserecord `BaseRecord`}\n * @typeParam TError - Custom error object that extends {@link https://refine.dev/docs/core/interfaceReferences#httperror `HttpError`}\n * @typeParam TQuery - Values for query params\n * @typeParam TPayload - Values for params\n *\n */\nexport const useCustom = <\n    TData = BaseRecord,\n    TError extends HttpError = HttpError,\n    TQuery = unknown,\n    TPayload = unknown,\n>({\n    url,\n    method,\n    config,\n    queryOptions,\n    metaData,\n    dataProviderName,\n}: UseCustomProps<TData, TError, TQuery, TPayload>): QueryObserverResult<\n    CustomResponse<TData>,\n    TError\n> => {\n    const dataProvider = useDataProvider();\n\n    const { custom } = dataProvider(dataProviderName);\n    if (custom) {\n        const queryResponse = useQuery<CustomResponse<TData>, TError>(\n            [\n                dataProviderName,\n                \"custom\",\n                method,\n                url,\n                { ...config, ...metaData },\n            ],\n            () => custom<TData>({ url, method, ...config, metaData }),\n            {\n                ...queryOptions,\n                onSuccess: (data) => {\n                    queryOptions?.onSuccess?.(data);\n                },\n                onError: (err: TError) => {\n                    queryOptions?.onError?.(err);\n                },\n            },\n        );\n        return queryResponse;\n    } else {\n        throw Error(\"Not implemented custom on data provider.\");\n    }\n};","import { useCallback, useContext } from \"react\";\n\nimport { DataContext } from \"../../contexts/data\";\nimport {\n    IDataContextProvider,\n    IDataMultipleContextProvider,\n} from \"../../interfaces\";\n\nexport const useDataProvider = (): ((\n    dataProviderName?: string,\n) => IDataContextProvider) => {\n    const context = useContext<IDataMultipleContextProvider>(DataContext);\n\n    const handleDataProvider = useCallback(\n        (dataProviderName?: string) => {\n            if (dataProviderName) {\n                const dataProvider = context[dataProviderName];\n                if (!dataProvider) {\n                    throw new Error(\n                        `\"${dataProviderName}\" Data provider not found`,\n                    );\n                }\n                return context[dataProviderName];\n            }\n            if (context.default) {\n                return context.default;\n            } else\n                throw new Error(\n                    `There is no \"default\" data provider. Please pass dataProviderName.`,\n                );\n        },\n        [context],\n    );\n\n    return handleDataProvider;\n};","import { useCallback } from \"react\";\nimport { useQueryClient } from \"react-query\";\n\nimport { queryKeys } from \"../../definitions/helpers/queryKeys\";\nimport { BaseKey, IQueryKeys } from \"../../interfaces\";\n\nexport type UseInvalidateProp = {\n    resource: string;\n    id?: BaseKey;\n    dataProviderName?: string;\n    invalidates: Array<keyof IQueryKeys> | false;\n};\n\nexport const useInvalidate = (): ((props: UseInvalidateProp) => void) => {\n    const queryClient = useQueryClient();\n\n    const invalidate = useCallback(\n        ({\n            resource,\n            dataProviderName,\n            invalidates,\n            id,\n        }: UseInvalidateProp) => {\n            if (invalidates === false) {\n                return;\n            }\n            const queryKey = queryKeys(resource, dataProviderName);\n\n            invalidates.forEach((key) => {\n                switch (key) {\n                    case \"all\":\n                        queryClient.invalidateQueries(queryKey.all);\n                        break;\n                    case \"list\":\n                        queryClient.invalidateQueries(queryKey.list());\n                        break;\n                    case \"many\":\n                        queryClient.invalidateQueries(queryKey.many());\n                        break;\n                    case \"resourceAll\":\n                        queryClient.invalidateQueries(queryKey.resourceAll);\n                        break;\n                    case \"detail\":\n                        queryClient.invalidateQueries(\n                            queryKey.detail(id || \"\"),\n                        );\n                        break;\n                    default:\n                        break;\n                }\n            });\n        },\n        [],\n    );\n\n    return invalidate;\n};","import { useContext } from \"react\";\n\nimport { SmeltContext } from \"../../contexts/smelt\";\nimport { ISmeltContext } from \"../../interfaces\";\n\ntype UseMutationModeType = () => {\n    mutationMode: ISmeltContext[\"mutationMode\"];\n    undoableTimeout: ISmeltContext[\"undoableTimeout\"];\n};\n\nexport const useMutationMode: UseMutationModeType = () => {\n    const { mutationMode, undoableTimeout } = useContext(SmeltContext);\n\n    return { mutationMode, undoableTimeout };\n};","import React from \"react\";\n\nimport { ISmeltContext, ISmeltContextProvider } from \"./ISmeltContext\";\n\nexport const SmeltContext = React.createContext<ISmeltContext>({\n  mutationMode: \"pessimistic\",\n  warnWhenUnsavedChanges: false,\n  syncWithLocation: false,\n  undoableTimeout: 5000,\n});\n\nexport const SmeltContextProvider: React.FC<ISmeltContextProvider> = ({\n  mutationMode,\n  warnWhenUnsavedChanges,\n  syncWithLocation,\n  undoableTimeout,\n  children,\n}) => {\n  return (\n    <SmeltContext.Provider\n      value={{\n        mutationMode,\n        warnWhenUnsavedChanges,\n        syncWithLocation,\n        undoableTimeout,\n      }}\n    >\n      {children}\n    </SmeltContext.Provider>\n  );\n};\n","import { useContext } from \"react\";\n\nimport { AuthContext } from \"../../../contexts/auth\";\nimport { IAuthContext } from \"../../../interfaces\";\nimport { useQuery, UseQueryResult, UseQueryOptions } from \"react-query\";\n\nexport const usePermissions = <TData = any>(\n    options?: UseQueryOptions<TData>,\n): UseQueryResult<TData, unknown> => {\n    const { getPermissions } = useContext<IAuthContext>(AuthContext);\n\n    const queryResponse = useQuery<TData>(\n        \"usePermissions\",\n        getPermissions,\n        options,\n    );\n\n    return queryResponse;\n};","import React from \"react\";\n\nimport { AuthContext } from \"../../../contexts/auth\";\nimport { IAuthContext } from \"../../../interfaces\";\nimport { useQuery, UseQueryResult } from \"react-query\";\n\n\nexport const useGetIdentity = <TData = any>(): UseQueryResult<\n    TData,\n    unknown\n> => {\n    const { getUserIdentity } = React.useContext<IAuthContext>(AuthContext);\n\n    const queryResponse = useQuery<TData>(\"getUserIdentity\", getUserIdentity!, {\n        enabled: !!getUserIdentity,\n    });\n\n    return queryResponse;\n};","import React from \"react\";\nimport { useMutation, UseMutationResult } from \"react-query\";\n\nimport { AuthContext } from \"../../../contexts/auth\";\nimport { IAuthContext, TLogoutData } from \"../../../interfaces\";\n\n\nexport const useLogout = <TVariables = void>(): UseMutationResult<\n    TLogoutData,\n    Error,\n    TVariables,\n    unknown\n> => {\n    const { logout: logoutFromContext } =\n        React.useContext<IAuthContext>(AuthContext);\n\n    const queryResponse = useMutation<TLogoutData, Error, TVariables, unknown>(\n        \"useLogout\",\n        logoutFromContext,\n        {\n            onSuccess: () => {\n               \n            },\n            onError: (error: Error) => {\n               console.log(error)\n            },\n        },\n    );\n\n    return queryResponse;\n};","import React from \"react\";\nimport { useMutation, UseMutationResult } from \"react-query\";\n\nimport { AuthContext } from \"../../../contexts/auth\";\n\nimport { IAuthContext, TLoginData } from \"../../../interfaces\";\n\n\nexport const useLogin = <TVariables = {}>(): UseMutationResult<\n    TLoginData,\n    Error,\n    TVariables,\n    unknown\n> => {\n    const { login: loginFromContext } =\n        React.useContext<IAuthContext>(AuthContext);\n\n    const queryResponse = useMutation<TLoginData, Error, TVariables, unknown>(\n        \"useLogin\",\n        loginFromContext,\n        {\n            onSuccess: (redirectPathFromAuth) => {\n               \n            },\n            onError: (error: any) => {\n               \n            },\n        },\n    );\n\n    return queryResponse;\n};","import { useContext } from \"react\";\nimport { useQuery, UseQueryResult } from \"react-query\";\n\nimport { AuthContext } from \"../../../contexts/auth\";\nimport { IAuthContext } from \"../../../interfaces\";\n\nexport const useAuthenticated = (\n    params?: any,\n): UseQueryResult<any, unknown> => {\n    const { checkAuth } = useContext<IAuthContext>(AuthContext);\n\n    const queryResponse = useQuery(\n        [\"useAuthenticated\", params],\n        () => checkAuth(params),\n        {\n            retry: false,\n        },\n    );\n\n    return queryResponse;\n};","import { useContext } from \"react\";\n\nimport { AuthContext } from \"../../../contexts/auth\";\nimport { IAuthContext } from \"../../../interfaces\";\n\nexport const useIsAuthenticated = () => {\n    const { isAuthenticated } = useContext<IAuthContext>(AuthContext);\n\n    return isAuthenticated;\n};","import { useContext } from \"react\";\nimport { AuthContext } from \"../../contexts/auth\";\nimport { IAuthContext } from \"../../interfaces\";\n\n/**\n * A hook that the UI uses\n * @internal\n */\nexport const useIsExistAuthentication = (): boolean => {\n    const { isProvided } = useContext<IAuthContext>(AuthContext);\n\n    return isProvided || false;\n};"],"mappings":"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","names":[]}